"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stopLocalFhenix = exports.runLocalFhenixSeparateProcess = exports.isContainerRunning = exports.pullDockerContainer = exports.doesImageExist = exports.isDockerInstalled = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const const_1 = require("./const");
const isDockerInstalled = () => {
    let stdout = "";
    try {
        stdout = (0, child_process_1.execSync)(`docker -v`).toString();
        return !!stdout;
    }
    catch (error) {
        return false;
    }
};
exports.isDockerInstalled = isDockerInstalled;
const doesImageExist = (image) => {
    if (image.split(":").length !== 2) {
        return false;
    }
    const [containerName, containerTag] = image.split(":");
    let stdout = "";
    try {
        stdout = (0, child_process_1.execSync)(`docker images`).toString();
        return !!stdout
            .split("\n")
            .find((line) => line.includes(containerName) && line.includes(containerTag));
    }
    catch (error) {
        return false;
    }
};
exports.doesImageExist = doesImageExist;
const pullDockerContainer = (image) => {
    if ((0, exports.doesImageExist)(image)) {
        return;
    }
    console.info(chalk_1.default.green(`Downloading docker image ${image}...`));
    try {
        const commandToRun = `docker pull ${image}`;
        (0, child_process_1.execSync)(commandToRun);
        console.info(chalk_1.default.green("done!"));
        // spawn("/usr/bin/env", commandToRun.split(" "));
    }
    catch (error) {
        return false;
    }
};
exports.pullDockerContainer = pullDockerContainer;
const isContainerRunning = (name) => {
    let stdout = "";
    try {
        // Using spawnSync because Windows doesn't like it when we use parentheses with execSync
        stdout = (0, child_process_1.spawnSync)("docker", [
            "ps",
            "-a",
            "--format",
            '{"name": "{{ .Names }}", "ports": "{{ .Ports }}", "image": "{{ .Image }}"}',
        ]).stdout?.toString();
    }
    catch (error) {
        return false;
    }
    try {
        const [existingLocalfhenix] = stdout
            .split("\n")
            .map((line) => {
            try {
                return JSON.parse(line);
            }
            catch (error) {
                return {}; // avoid null pointer exception on container.name
            }
        })
            .filter((container) => container.name === name);
        return !!existingLocalfhenix;
    }
    catch (e) {
        return false;
    }
};
exports.isContainerRunning = isContainerRunning;
const runLocalFhenixSeparateProcess = async (rpc, ws, faucet, image) => {
    (0, child_process_1.execSync)(`docker run -d --rm -p "${rpc}":8547 -p "${ws}":8548 -p "${faucet}":3000 --name "${const_1.LOCALFHENIX_CONTAINER_NAME}" "${image}"`);
};
exports.runLocalFhenixSeparateProcess = runLocalFhenixSeparateProcess;
const stopLocalFhenix = () => {
    try {
        (0, child_process_1.execSync)(`docker rm -f "${const_1.LOCALFHENIX_CONTAINER_NAME}"`);
    }
    catch (error) {
        if (!error?.message?.includes("No such container")) {
            console.error(`error: ${error}`);
        }
    }
};
exports.stopLocalFhenix = stopLocalFhenix;
//# sourceMappingURL=docker.js.map