"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const ethers_1 = require("ethers");
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const common_1 = require("./common");
const const_1 = require("./const");
const FhenixHardhatRuntimeEnvironment_1 = require("./FhenixHardhatRuntimeEnvironment");
require("./type-extensions");
// This import is needed to let the TypeScript compiler know that it should include your type
// extensions in your npm package's types file.
(0, config_1.extendEnvironment)((hre) => {
    hre.fhenixjs = (0, plugins_1.lazyObject)(() => {
        const fhenix = new FhenixHardhatRuntimeEnvironment_1.FhenixHardhatRuntimeEnvironment(hre, {
            rpcPort: 42069,
            wsPort: 42070,
            faucetPort: 42000,
        });
        return fhenix;
    });
});
(0, config_1.extendConfig)((config, userConfig) => {
    if (userConfig.networks && userConfig.networks.localfhenix) {
        return;
    }
    config.networks.localfhenix = {
        gas: "auto",
        gasMultiplier: 1.2,
        gasPrice: "auto",
        timeout: 10000,
        httpHeaders: {},
        url: "http://127.0.0.1:42069",
        accounts: {
            mnemonic: "demand hotel mass rally sphere tiger measure sick spoon evoke fashion comfort",
            path: "m/44'/60'/0'/0",
            initialIndex: 0,
            count: 20,
            passphrase: "",
        },
    };
});
// Main task of the plugin. It starts the server and listens for requests.
(0, config_1.task)(const_1.TASK_FHENIX_USE_FAUCET, "Fund an account from the faucet")
    .addOptionalParam("address", "Address to fund", undefined, config_1.types.string)
    .addOptionalParam("account", "account number to fund", 0, config_1.types.int)
    .addOptionalParam("url", "Optional Faucet URL", "http://localhost:42000", config_1.types.string)
    .setAction(async ({ address, account, url, }, { network }) => {
    if (network.name !== "localfhenix" && !url) {
        console.info(chalk_1.default.yellow(`Programmatic faucet only supported for localfhenix. Please provide a faucet url, or use the public testnet faucet at https://faucet.fhenix.zone`));
        return;
    }
    const networkConfig = network.config;
    let foundAddress = "";
    if (Object(networkConfig).hasOwnProperty("url")) {
        const x = networkConfig;
        if (x.accounts === "remote") {
            console.log(chalk_1.default.yellow(`Remote network detected, cannot use faucet`));
            return;
        }
        else if (Object(x.accounts).hasOwnProperty("mnemonic")) {
            const networkObject = x.accounts;
            const mnemonic = networkObject.mnemonic;
            const path = `${networkObject.path || "m/44'/60'/0'/0"}/${account || networkObject.initialIndex || 0}`;
            const wallet = ethers_1.HDNodeWallet.fromPhrase(mnemonic, "", path);
            foundAddress = wallet.address;
        }
        else {
            const accounts = x.accounts;
            const privateKey = accounts[account || 0];
            const wallet = new ethers_1.Wallet(privateKey);
            foundAddress = wallet.address;
        }
    }
    const myAddress = address || foundAddress;
    if (!myAddress) {
        console.info(chalk_1.default.red(`Failed to get address from hardhat`));
        return;
    }
    console.info(chalk_1.default.green(`Getting funds from faucet for ${myAddress}`));
    try {
        await (0, common_1.getFunds)(myAddress, url);
        console.info(chalk_1.default.green(`Success!`));
    }
    catch (e) {
        console.info(chalk_1.default.red(`failed to get funds from faucet @ ${url} for ${address}: ${e}`));
    }
});
//# sourceMappingURL=index.js.map